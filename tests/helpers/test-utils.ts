import * as fs from 'fs-extra';
import * as path from 'path';
import * as os from 'os';

/**
 * Creates a temporary test directory.
 * Returns the absolute path to the directory.
 */
export async function createTempDir(prefix = 'mcp-toggle-test-'): Promise<string> {
  const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), prefix));
  return tempDir;
}

/**
 * Cleans up a temporary test directory.
 */
export async function cleanupTempDir(dirPath: string): Promise<void> {
  await fs.remove(dirPath);
}

/**
 * Creates a mock .claude.json file with specified MCP servers.
 */
export async function createMockClaudeJson(
  dirPath: string,
  servers: Record<string, unknown>
): Promise<string> {
  await fs.ensureDir(dirPath);
  const filePath = path.join(dirPath, '.claude.json');
  const content = JSON.stringify({ mcpServers: servers }, null, 2);
  await fs.writeFile(filePath, content, 'utf-8');
  return filePath;
}

/**
 * Creates mock memory files in .claude/memories/ directory.
 */
export async function createMockMemoryFiles(
  dirPath: string,
  files: Record<string, string>
): Promise<string[]> {
  const memoriesDir = path.join(dirPath, '.claude', 'memories');
  await fs.ensureDir(memoriesDir);

  const paths: string[] = [];
  for (const [filename, content] of Object.entries(files)) {
    const filePath = path.join(memoriesDir, filename);
    await fs.ensureDir(path.dirname(filePath));
    await fs.writeFile(filePath, content, 'utf-8');
    paths.push(filePath);
  }

  return paths;
}

/**
 * Creates a mock blocked.md file.
 */
export async function createMockBlockedMd(
  dirPath: string,
  blockedItems: Array<{ type: 'mcp' | 'memory'; identifier: string }>
): Promise<string> {
  const blockedMdPath = path.join(dirPath, '.claude', 'blocked.md');
  await fs.ensureDir(path.dirname(blockedMdPath));

  const lines = [
    '# Blocked MCP Servers and Memory Files',
    '# Generated by mcp-toggle',
    `# Last updated: ${new Date().toISOString()}`,
    '',
    '## MCP Servers',
  ];

  for (const item of blockedItems.filter((i) => i.type === 'mcp')) {
    lines.push(`mcp:${item.identifier}`);
  }

  lines.push('', '## Memory Files');

  for (const item of blockedItems.filter((i) => i.type === 'memory')) {
    lines.push(`memory:${item.identifier}`);
  }

  const content = lines.join('\n') + '\n';
  await fs.writeFile(blockedMdPath, content, 'utf-8');

  return blockedMdPath;
}

/**
 * Reads the content of a file.
 */
export async function readFile(filePath: string): Promise<string> {
  return await fs.readFile(filePath, 'utf-8');
}

/**
 * Checks if a file exists.
 */
export async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}
