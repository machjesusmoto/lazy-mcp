import { loadBlockedItems, saveBlockedItems } from '../../src/core/blocked-manager';
import { createTempDir, cleanupTempDir, createMockBlockedMd } from '../helpers/test-utils';
import * as path from 'path';
import * as fs from 'fs-extra';

describe('blocked-manager', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
  });

  afterEach(async () => {
    await cleanupTempDir(tempDir);
  });

  describe('loadBlockedItems', () => {
    it('should parse blocked.md format correctly', async () => {
      await createMockBlockedMd(tempDir, [
        { type: 'mcp', identifier: 'filesystem' },
        { type: 'mcp', identifier: 'sequential-thinking' },
        { type: 'memory', identifier: 'old-notes.md' },
      ]);

      const items = await loadBlockedItems(tempDir);

      expect(items).toHaveLength(3);
      expect(items.filter((i) => i.type === 'mcp')).toHaveLength(2);
      expect(items.filter((i) => i.type === 'memory')).toHaveLength(1);
      expect(items.find((i) => i.identifier === 'filesystem')).toBeDefined();
    });

    it('should handle empty blocked.md', async () => {
      const blockedMdPath = path.join(tempDir, '.claude', 'blocked.md');
      await fs.ensureDir(path.dirname(blockedMdPath));
      await fs.writeFile(
        blockedMdPath,
        '# Blocked MCP Servers and Memory Files\n\n## MCP Servers\n\n## Memory Files\n',
        'utf-8'
      );

      const items = await loadBlockedItems(tempDir);

      expect(items).toEqual([]);
    });

    it('should handle missing blocked.md', async () => {
      // No blocked.md created
      const items = await loadBlockedItems(tempDir);

      expect(items).toEqual([]);
    });

    it('should skip invalid entries gracefully', async () => {
      const blockedMdPath = path.join(tempDir, '.claude', 'blocked.md');
      await fs.ensureDir(path.dirname(blockedMdPath));

      const content = `# Blocked MCP Servers and Memory Files

## MCP Servers
mcp:valid-server
invalid-line-no-prefix
mcp:another-valid
: no-identifier

## Memory Files
memory:valid-file.md
not-a-valid-entry
memory:another-valid.md
`;

      await fs.writeFile(blockedMdPath, content, 'utf-8');

      const items = await loadBlockedItems(tempDir);

      // Should only parse valid entries
      expect(items).toHaveLength(4);
      expect(items.every((i) => i.identifier.length > 0)).toBe(true);
    });

    it('should ignore comment lines', async () => {
      const blockedMdPath = path.join(tempDir, '.claude', 'blocked.md');
      await fs.ensureDir(path.dirname(blockedMdPath));

      const content = `# Blocked MCP Servers and Memory Files
# This is a comment
# Generated by mcp-toggle

## MCP Servers
# Another comment
mcp:filesystem

## Memory Files
# Memory files section
memory:notes.md
`;

      await fs.writeFile(blockedMdPath, content, 'utf-8');

      const items = await loadBlockedItems(tempDir);

      expect(items).toHaveLength(2);
    });

    it('should set blockedAt timestamp', async () => {
      await createMockBlockedMd(tempDir, [{ type: 'mcp', identifier: 'filesystem' }]);

      const items = await loadBlockedItems(tempDir);

      expect(items[0].blockedAt).toBeDefined();
      expect(items[0].blockedAt).toBeInstanceOf(Date);
    });

    it('should set blockedBy to mcp-toggle', async () => {
      await createMockBlockedMd(tempDir, [{ type: 'mcp', identifier: 'filesystem' }]);

      const items = await loadBlockedItems(tempDir);

      expect(items[0].blockedBy).toBe('mcp-toggle');
    });

    it('should handle whitespace in entries', async () => {
      const blockedMdPath = path.join(tempDir, '.claude', 'blocked.md');
      await fs.ensureDir(path.dirname(blockedMdPath));

      const content = `## MCP Servers
  mcp:server-with-spaces
mcp:another-server
`;

      await fs.writeFile(blockedMdPath, content, 'utf-8');

      const items = await loadBlockedItems(tempDir);

      expect(items).toHaveLength(2);
      expect(items[0].identifier).toBe('server-with-spaces');
    });

    it('should handle paths with subdirectories in memory entries', async () => {
      await createMockBlockedMd(tempDir, [
        { type: 'memory', identifier: 'subdir/file.md' },
        { type: 'memory', identifier: 'deep/nested/file.md' },
      ]);

      const items = await loadBlockedItems(tempDir);

      expect(items).toHaveLength(2);
      expect(items.every((i) => i.identifier.includes('/'))).toBe(true);
    });
  });

  describe('saveBlockedItems', () => {
    it('should write blocked.md format correctly', async () => {
      const items = [
        {
          type: 'mcp' as const,
          identifier: 'filesystem',
          blockedAt: new Date(),
          blockedBy: 'mcp-toggle',
        },
        {
          type: 'mcp' as const,
          identifier: 'sequential',
          blockedAt: new Date(),
          blockedBy: 'mcp-toggle',
        },
        {
          type: 'memory' as const,
          identifier: 'notes.md',
          blockedAt: new Date(),
          blockedBy: 'mcp-toggle',
        },
      ];

      await saveBlockedItems(tempDir, items);

      // Verify file was created
      const blockedMdPath = path.join(tempDir, '.claude', 'blocked.md');
      expect(await fs.pathExists(blockedMdPath)).toBe(true);

      // Verify content format
      const content = await fs.readFile(blockedMdPath, 'utf-8');
      expect(content).toContain('# Blocked MCP Servers and Memory Files');
      expect(content).toContain('## MCP Servers');
      expect(content).toContain('mcp:filesystem');
      expect(content).toContain('mcp:sequential');
      expect(content).toContain('## Memory Files');
      expect(content).toContain('memory:notes.md');

      // Verify can be read back
      const reloadedItems = await loadBlockedItems(tempDir);
      expect(reloadedItems).toHaveLength(3);
    });

    it('should create .claude/ directory if missing', async () => {
      // Ensure .claude doesn't exist
      const claudeDir = path.join(tempDir, '.claude');
      expect(await fs.pathExists(claudeDir)).toBe(false);

      const items = [
        {
          type: 'mcp' as const,
          identifier: 'test-server',
          blockedAt: new Date(),
          blockedBy: 'mcp-toggle',
        },
      ];

      await saveBlockedItems(tempDir, items);

      // Verify directory was created
      expect(await fs.pathExists(claudeDir)).toBe(true);

      // Verify file was created inside
      const blockedMdPath = path.join(claudeDir, 'blocked.md');
      expect(await fs.pathExists(blockedMdPath)).toBe(true);
    });

    it('should handle empty items array', async () => {
      await saveBlockedItems(tempDir, []);

      const blockedMdPath = path.join(tempDir, '.claude', 'blocked.md');
      expect(await fs.pathExists(blockedMdPath)).toBe(true);

      const content = await fs.readFile(blockedMdPath, 'utf-8');
      expect(content).toContain('## MCP Servers');
      expect(content).toContain('## Memory Files');

      // Should have headers but no entries
      const lines = content.split('\n').filter((l) => l.startsWith('mcp:') || l.startsWith('memory:'));
      expect(lines).toHaveLength(0);
    });

    it('should update existing blocked.md', async () => {
      // Create initial blocked.md
      const initialItems = [
        {
          type: 'mcp' as const,
          identifier: 'old-server',
          blockedAt: new Date(),
          blockedBy: 'mcp-toggle',
        },
      ];

      await saveBlockedItems(tempDir, initialItems);

      // Update with new items
      const updatedItems = [
        {
          type: 'mcp' as const,
          identifier: 'new-server',
          blockedAt: new Date(),
          blockedBy: 'mcp-toggle',
        },
        {
          type: 'memory' as const,
          identifier: 'new-file.md',
          blockedAt: new Date(),
          blockedBy: 'mcp-toggle',
        },
      ];

      await saveBlockedItems(tempDir, updatedItems);

      // Verify old item replaced
      const blockedMdPath = path.join(tempDir, '.claude', 'blocked.md');
      const content = await fs.readFile(blockedMdPath, 'utf-8');

      expect(content).toContain('mcp:new-server');
      expect(content).toContain('memory:new-file.md');
      expect(content).not.toContain('old-server');
    });

    it('should handle items with nested paths', async () => {
      const items = [
        {
          type: 'memory' as const,
          identifier: 'subdir/nested/file.md',
          blockedAt: new Date(),
          blockedBy: 'mcp-toggle',
        },
      ];

      await saveBlockedItems(tempDir, items);

      const blockedMdPath = path.join(tempDir, '.claude', 'blocked.md');
      const content = await fs.readFile(blockedMdPath, 'utf-8');

      expect(content).toContain('memory:subdir/nested/file.md');

      // Verify can be read back
      const reloadedItems = await loadBlockedItems(tempDir);
      expect(reloadedItems[0].identifier).toBe('subdir/nested/file.md');
    });

    it('should include timestamp in header', async () => {
      const items = [
        {
          type: 'mcp' as const,
          identifier: 'test',
          blockedAt: new Date(),
          blockedBy: 'mcp-toggle',
        },
      ];

      await saveBlockedItems(tempDir, items);

      const blockedMdPath = path.join(tempDir, '.claude', 'blocked.md');
      const content = await fs.readFile(blockedMdPath, 'utf-8');

      expect(content).toContain('# Last updated:');
      expect(content).toMatch(/\d{4}-\d{2}-\d{2}/); // ISO date format
    });

    it('should preserve file permissions', async () => {
      const items = [
        {
          type: 'mcp' as const,
          identifier: 'test',
          blockedAt: new Date(),
          blockedBy: 'mcp-toggle',
        },
      ];

      await saveBlockedItems(tempDir, items);

      const blockedMdPath = path.join(tempDir, '.claude', 'blocked.md');
      const stats = await fs.stat(blockedMdPath);

      // File should be readable and writable
      expect((stats.mode & 0o600) === 0o600).toBe(true);
    });
  });
});
